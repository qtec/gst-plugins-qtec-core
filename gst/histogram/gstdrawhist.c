 /* GStreamer
 * Copyright (C) 2015 Dimitrios Katsaros <patcherwork@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
 * Boston, MA 02110-1335, USA.
 */
/**
 * SECTION:element-gstdrawhist
 *
 * The drawhist element is used to create a visual presentation fo the
 * histogram data being generated by the vhist element. It is mandatory
 * that the histogram metadata be present on the streamed data.
 *
 * <refsect2>
 * <title>Example launch line</title>
 * |[
 * gst-launch videotestsrc ! vhist binno=5 ! drawhist ! glimagesink
 * ]|
 * Creates a test image, calculates the histogram for the generated image and
 * presents it
 * </refsect2>
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <inttypes.h>
#include <gst/gst.h>
#include <gst/video/video.h>
#include <gst/video/gstvideofilter.h>
#include "gstdrawhist.h"
#include <gst/histogram/gsthistmeta.h>

GST_DEBUG_CATEGORY_STATIC (gst_drawhist_debug_category);
#define GST_CAT_DEFAULT gst_drawhist_debug_category

/* prototypes */


static GstFlowReturn gst_drawhist_transform_frame (GstVideoFilter * filter,
    GstVideoFrame * inframe, GstVideoFrame * outframe);

enum
{
  PROP_0
};

/* pad templates */

#define VIDEO_SRC_CAPS \
    GST_VIDEO_CAPS_MAKE("{ GRAY8 }")

#define VIDEO_SINK_CAPS \
    GST_VIDEO_CAPS_MAKE("{ GRAY8 }")


/* class initialization */

G_DEFINE_TYPE_WITH_CODE (GstDrawhist, gst_drawhist, GST_TYPE_VIDEO_FILTER,
    GST_DEBUG_CATEGORY_INIT (gst_drawhist_debug_category, "drawhist", 0,
        "debug category for drawhist element"));


static void
gst_drawhist_class_init (GstDrawhistClass * klass)
{

  GstVideoFilterClass *video_filter_class = GST_VIDEO_FILTER_CLASS (klass);

  /* Setting up pads and setting metadata should be moved to
     base_class_init if you intend to subclass this class. */
  gst_element_class_add_pad_template (GST_ELEMENT_CLASS (klass),
      gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
          gst_caps_from_string (VIDEO_SRC_CAPS)));
  gst_element_class_add_pad_template (GST_ELEMENT_CLASS (klass),
      gst_pad_template_new ("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
          gst_caps_from_string (VIDEO_SINK_CAPS)));

  gst_element_class_set_static_metadata (GST_ELEMENT_CLASS (klass),
      "Draw Histogram", "Transform/Metadata/Video",
      "Create graphical reprisentation of histogram metadata",
      "Dimitrios Katsaros <patcherwork@gmail.com>");

  video_filter_class->transform_frame =
      GST_DEBUG_FUNCPTR (gst_drawhist_transform_frame);

}

static void
gst_drawhist_init (GstDrawhist * drawhist)
{
}

/* transform */
static GstFlowReturn
gst_drawhist_transform_frame (GstVideoFilter * filter, GstVideoFrame * inframe,
    GstVideoFrame * outframe)
{

  GstHistMeta *meta =
      (GstHistMeta *) gst_buffer_get_gst_hist_meta (inframe->buffer);
  int i, j, z, axispos, tar, maxsize, startw, avlw, wbuffer;
  int avlw_buff, avlh, hbuffer, avlh_buff;
  int width = outframe->info.width;
  int height = outframe->info.height;
  int size = outframe->info.size;
  guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (outframe, 0);

  if (!meta) {
    GST_DEBUG ("Histogram metadata not found, terminating pipeline");
    return GST_FLOW_ERROR;
  }

  /* first clear image frame */
  for (i = 0; i < size; i++) {
    data[i] = 0;
  }

  GST_DEBUG ("number of bins: %d min val: %d avg val: %f max val: %d median val: %d (bin nr: %d) mode val: %d (bin nr: %d)\n",
		  	  meta->bin_no,
			  meta->minval, meta->avgval, meta->maxval,
			  meta->medianid*(256/meta->bin_no), meta->medianid,
			  meta->modeid*(256/meta->bin_no), meta->modeid);

  /* second, create axes */
  axispos = 10;
  tar = width * 0.05;
  for (j = axispos; j < height - axispos; j++) {
    data[j * width + tar] = 255;
  }

  tar = (height * 0.95) * width;
  for (j = axispos; j < width - axispos; j++) {
    data[tar + j] = 255;
  }

  /* get mode value */
  maxsize = meta->bins[meta->modeid];

  /* draw the histogram */

  /* calculate histogram variables */
  startw = (width * 0.05);
  avlw = width - startw - axispos;
  wbuffer = avlw * 0.05;
  avlw_buff = avlw - 2 * wbuffer;
  avlh = height * 0.95;
  hbuffer = avlh * 0.1;
  avlh_buff = avlh - hbuffer;

  for (i = 0; i < meta->bin_no; i++) {
    int wlength = avlw_buff / meta->bin_no;
    int hpos = (1 - (float) meta->bins[i] / maxsize) * avlh_buff;
    for (j = 0; j < wlength; j++) {
      for (z = (hpos + hbuffer); z < avlh; z++)
        data[z * width + (wbuffer + startw + wlength * i + j)] =
            (guint8)(20 + (235.0 / meta->bin_no) * i);
    }
  }
  return GST_FLOW_OK;
}

gboolean
gst_drawhist_plugin_init (GstPlugin * plugin)
{

  GST_DEBUG_CATEGORY_INIT (gst_drawhist_debug_category, "drawhist", 0,
      "debugging for histogram visualizer");

  return gst_element_register (plugin, "drawhist", GST_RANK_NONE,
      GST_TYPE_DRAWHIST);
}
